(* =========================================================
	Sophia (AI₂O³) - BNF Grammar Definition v1.6.6
	"The Determinism Update"
	
	Philosophy:
		- Auto-Iteration: Universal iteration source support
		- O(N) Enforcement: Nested loops forbidden
		- Zero-Offset-Error: Range-based indexing
		- Physicality: Array, I/O Gate, and Lens models
		- Determinism: Side-effect-free expression via Pure Functions
	========================================================= *)

(* =========================================================
	PROGRAM STRUCTURE
	========================================================= *)

<Program>		::= <Definition>*

<Definition>	::= <SchemaDef> 
				| <TaskDef>      (* 副作用あり & *)
				| <PureDef>      (* 副作用なし ! *)
				| <SceneDef> 
				| <ConstDef>

(* =========================================================
	SCHEMA DEFINITION (テーブル構造定義)
	========================================================= *)

<SchemaDef>		::= "#" <Ident> <FieldsBlock> <CapacityBlock>?
<FieldsBlock>	::= "[" <TypedFields> "]"
<TypedFields>	::= <FieldDef> ( "," <FieldDef> )*
<FieldDef>		::= <Ident> ":" <Type>

<Type>			::= "i8" | "i16" | "i32" | "u8" | "u16" | "u32" 
				| "f32" | "f64" | "str" | "bool"

<CapacityBlock>	::= "[" ( <Int> | <Ident> ) "]"

(* =========================================================
	CONSTANT DEFINITION (ハッシュマップ型定数)
	========================================================= *)

<ConstDef>		::= "%" <Ident> "[" <HashList> "]"
<HashList>		::= <HashPair> ( "," <HashPair> )*
<HashPair>		::= <Ident> ( ":" <Expression> )?

(* =========================================================
	SCENE DEFINITION (物理レンズモデル)
	========================================================= *)

<SceneDef>		::= "scene" <Ident> <LensSelector> "[" <EventDef>* "]"
<LensSelector>	::= "]>[" | "|>[" | "[>["
<EventDef>		::= "on" <Ident> <ArgParamList>? <BodyBlock>
<ArgParamList>	::= "[" ( "." <Ident> ( "," "." <Ident> )* )? "]"

(* =========================================================
	TASK & PURE FUNCTION DEFINITION (タスクと純粋関数)
	========================================================= *)

<TaskDef>		::= "&" <Ident> "[" <ParamList>? "]" <BodyBlock>
<PureDef>		::= "!" <Ident> "[" <ParamList>? "]" <BodyBlock>
<ParamList>		::= <Ident> ( "," <Ident> )*

(* =========================================================
	STATEMENTS & FLOW CONTROL (実行文と制御)
	========================================================= *)

<BodyBlock>		::= "[" <Statement>* <ExitControl>? "]"

<Statement>		::= <IterateBlock>
				| <CollectionBlock>
				| <ListBlock>
				| <QAChain>
				| <Action>
				| <SapphireCall>
				| <TaskCall>      (* Task execution name&[] *)
				| <ExitControl>

(* --- QA CHAIN & TRY-FLOW --- *)
<QAChain>		::= <QPrefix> <BodyBlock> ( <ElseIfBlock> | <ElseBlock> )?
<QPrefix>		::= "?" "[" <Expression> "]" | "?!"
<ElseIfBlock>	::= "|?" <QAChain>
<ElseBlock>		::= "|!" ( "[" <Ident> "]" )? <BodyBlock>

(* --- SAPPHIRE CALL & I/O GATES (Namespaces) --- *)
<SapphireCall>	::= "$" "[" <Namespace> "." <Ident> <ArgList>? "]" <IOGate>?
<Namespace>		::= "scene" | "event" | "audio" | "net" | "ui" | "sys" | "math" | "file"
<IOGate>		::= "[" <IOParts> "]"
<IOParts>		::= <IOPart> ( "," <IOPart> )*
<IOPart>		::= "?" <Expression> | "_" <Expression> | "<" | ">" <Expression>? | "x"

(* --- EXIT CONTROL --- *)
<ExitControl>	::= <EndCap> | <OutGate>
<EndCap>		::= "^" <Int>? | "v" | "x"
<OutGate>		::= ">" <Expression>?

(* =========================================================
	ITERATION & COLLECTION
	========================================================= *)

<IterateBlock>	::= <IterSource> "*" <BodyBlock>
<IterSource>	::= <LValue> | <ListBlock> | <Int> | <Range> | "(" <Expression> ")"
<Range>			::= <Expression> ":" <Expression>

<CollectionBlock> ::= <Ident> "#" <Subject> <BodyBlock>?
<Subject>		::= <Int> | <Ident> | "*"

<ListBlock>		::= <Ident> "@" "[" <Range>? <GateOp> <Expression>? "]"
<GateOp>		::= "<" | ">" | "x" | "^" | "v" | "size"

(* =========================================================
	LVALUE & CALLS
	========================================================= *)

<LValue>		::= <Nature> <Ident> <SubAccess>*
<SubAccess>		::= "::" <Ident> | "%" <Ident> | "#" <Expression>
<Nature>		::= "#" | "%" | "@" | "$" | "&" | "." | "~"

<TaskCall>		::= <Ident> "&" "[" <ArgList>? "]"
<PureCall>		::= <Ident> "!" "[" <ArgList>? "]"
<ArgList>		::= <Expression> ( "," <Expression> )*

<Action>		::= <LValue> "[" <GeoOp> <Expression>? "]"
<GeoOp>			::= "<" | ">" | "x" | "+" | "-" | "*" | "/" | "%" | "^" | "v" | "_"

(* =========================================================
	EXPRESSIONS & LITERALS
	========================================================= *)

<Expression>	::= <LogicalOR>
<LogicalOR>		::= <LogicalAND> ( "or" <LogicalAND> )*
<LogicalAND>	::= <Comparison> ( "and" <Comparison> )*
<Comparison>	::= <MathExpr> ( <CompOp> <MathExpr> )*
<CompOp>		::= "eq" | "ne" | "gt" | "lt" | "ge" | "le"

<MathExpr>		::= <Term> ( ( "+" | "-" ) <Term> )*
<Term>			::= <Factor> ( ( "*" | "/" | "%" ) <Factor> )*
<Factor>		::= <Unary> | <Primary>
<Unary>			::= ( "!" | "-" ) <Primary>

<Primary>		::= <Literal> | <LValue> | <PureCall> | <SapphireCall> | "(" <Expression> ")"

<Literal>		::= <Int> | <Float> | <String> | <Bool>
<Int>			::= [0-9]+
<Float>			::= [0-9]+ "." [0-9]+
<String>		::= "\"" [^"]* "\""
<Bool>			::= "true" | "false"
<Ident>			::= [a-zA-Z_][a-zA-Z0-9_]*
